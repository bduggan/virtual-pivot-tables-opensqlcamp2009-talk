<html>
<head>
<title>017.pl</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script>
function navigate(e) {
    var keynum = (window.event) // IE
        ? e.keyCode
        : e.which;
    if (keynum == 8) {
        window.location = "016" + ".html";
        return false;
    }
    if (keynum == 13 || keynum == 32) {
        window.location = "018" + ".html";
        return false;
    }
    if (keynum == 73 || keynum == 105) {
        window.location = "index.html";
        return false;
    }
    return true;
}
</script>
</head>
<body onkeypress="return navigate(event)">
<pre>                                SQLite::VirtualTable::Pivot
  
  # Proof-of-concept implementation.
  # Table with columns named &quot;entity&quot;, &quot;attribute&quot;, &quot;value&quot;.
  
    package Test::Pivot;
    use DBI;
    use DBIx::Simple;
    use Data::Dumper;
    use base 'SQLite::VirtualTable';
    use strict;
    {  my ($sth, @row, @last_row, %queued, $first, $last, $done, $db );
    sub CREATE {
        # Create a new table.
        my ( $class, $module, $caller, $table, $base_table, @opts ) = @_;
        $db ||= DBIx::Simple-&gt;connect( &quot;dbi:SQLite:dbname=dbfile.db&quot;, &quot;&quot;, &quot;&quot; )
          or die DBIx::Simple-&gt;error;
        my @columns = (&quot;entity&quot;,
         $db-&gt;query(&quot;select distinct(attribute) from $base_table;&quot;)-&gt;flat);
        return bless {
            table      =&gt; $table,
            base_table =&gt; $base_table,
            columns    =&gt; \@columns
        }, $class;
    }
    sub DECLARE_SQL {
        # Declare the columns.
        my $self = shift;
        return sprintf &quot;CREATE TABLE %s (%s)&quot;,
            $self-&gt;{table}, (join ',', @{ $self-&gt;{columns} } );
    }
    sub OPEN {
       # Open a cursor
       my $self = shift;
       $sth = $db-&gt;dbh-&gt;prepare( &quot;select entity,attribute,value from $self-&gt;{base_table} order by entity&quot;)
         or die $DBI::errstr;
       $sth-&gt;execute or die $DBI::errstr;
       $last = !( @row = $sth-&gt;fetchrow_array );
       ($done,$first) = (0,1);
       $self-&gt;NEXT();
       return 1;
    }
    sub NEXT {
      # Advance the cursor one row.
      return if $done;
      $done = $last;
      while ($first || $row[0]==$last_row[0]) {
        $first             = 0;
        $queued{ $row[1] } = $row[2];
        $queued{entity}    = $row[0];
        @last_row          = @row;
        $last              = !( @row = $sth-&gt;fetchrow_array );
        last if $last;
      }
      @last_row = @row;
    }
    sub COLUMN  {
      # Retrieve the value in a column.
      my ($self, $cur, $n) = @_;
      return delete $queued{$self-&gt;{columns}[$n]};
    }
    sub EOF {
      # Is the cursor done?
      $done;
    }
    sub ROWID      { }
    sub CLOSE      { }
    sub DISCONNECT { }
    sub BEST_INDEX { (0, &quot;&quot;, undef, 0) }
    sub FILTER     { }
    sub DROP       { }
    *DESTROY = \&amp;DISCONNECT;
    *CONNECT = \&amp;CREATE;
    }
    1;
</pre>
</body>
